Computing factorials is trivial from an algorithmic point of view: successively multiplying a variable initialized to 1 by the integers 2 up to n (if any) will compute n!, provided the result fits in the variable. Interestingly, the factorial is often used as an example to illustrate recursive functions, while it is not intrinsically any more or less recursive (from a mathematical or computational point of view) than for instance a function computing the sum of the first n terms of a given sequence of numbers. The main difficulty in computing factorials is the size of the result. To assure that the result will fit for all legal values of even the smallest commonly used integral type (8-bit signed integers) would require more than 700 bits, so no reasonable specification of a factorial function using fixed-size types can avoid questions of overflow. The values 12! and 20! are the largest factorials that can be stored in, respectively, the 32 bit and 64 bit integers commonly used in personal computers. Although floating point representation of the result allows going a bit further, it remains quite limited by possible overflow. The largest factorial that most calculators can handle is 69!, because 69! < 10100 < 70!. Calculators that use 3-digit exponents can compute larger factorials, up to, for example, 253! ≈ 5.2×10499 on HP calculators and 449! ≈ 3.9×10997 on the TI-86. The calculator seen in Mac OS X, Microsoft Excel and Google Calculator, as well as the freeware Fox Calculator, can handle factorials up to 170!, which is the largest factorial that can be represented as a 64-bit IEEE 754 floating-point value. The scientific calculator in Windows XP is able to calculate factorials up to at least 100000!. Most software applications will compute small factorials by direct multiplication or table lookup. Larger factorial values can be approximated using Stirling's formula. Wolfram Alpha can calculate exact results for the ceiling function and floor function applied to the binary, natural and common logarithm of n! for values of n up to 249999, and up to 20,000,000! for the Integers. If very large exact factorials are needed, they can be computed using bignum arithmetic. In such computations speed may be gained[citation needed] by not sequentially multiplying the numbers up to (or down from) n into a single accumulator, but by partitioning the sequence so that the products for each of the two parts are approximately of the same size, compute those products recursively and then multiply. The asymptotically-best efficiency is obtained by computing n! from its prime factorization. As documented by Peter Borwein, prime factorization allows n! to be computed in time O(n(log n log log n)2), provided that a fast multiplication algorithm is used (for example, the Schönhage–Strassen algorithm).[4] Peter Luschny presents source code and benchmarks for several efficient factorial algorithms, with or without the use of a prime sieve.[5]
